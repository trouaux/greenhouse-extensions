name: Bump plugindefinition.yaml version on Chart.yaml change

on:
  pull_request:
    types: [opened, synchronize, reopened]
    paths:
      - "**/*/Chart.yaml"
      - "**/*/*/Chart.yaml"
permissions:
  actions: write
  contents: write
  pull-requests: write

jobs:
  bump-version:
    if: github.actor == 'renovate[bot]'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Find changed Chart.yaml files
        id: chartdiff
        run: |
          git fetch origin ${{ github.base_ref }}
          files=$(git diff --name-only origin/${{ github.base_ref }} HEAD | grep -E 'charts?/Chart.yaml$' || true)
          echo $files
          echo "files<<EOF"$'\n'"$files"$'\n'"EOF" >> $GITHUB_OUTPUT

      - name: Determine update level from PR description
        id: update_level
        run: |
          body="$PR_BODY"

          # Extract all update levels from the table
          levels=$(echo "$body" | grep -Eo '\|\s*(major|minor|patch)\s*\|' | grep -Eo '(major|minor|patch)')

          # Set priority: major > minor > patch
          update_level="patch"
          if echo "$levels" | grep -q 'major'; then
            update_level="major"
          elif echo "$levels" | grep -q 'minor'; then
            update_level="minor"
          fi

          echo "update_level=$update_level" >> $GITHUB_OUTPUT
        env:
          PR_BODY: ${{ github.event.pull_request.body }}
      
      - name: Sync plugindefinition.yaml version with Chart.yaml
        id: sync-versions
        if: steps.update_level.outputs.update_level != ''
        run: |
          set -e
          changes_made=false
          for chart in ${{ steps.chartdiff.outputs.files }}; do
            # Get the root directory (parent of charts/)
            root_dir=$(dirname "$(dirname "$chart")")
            # Get the chart version from Chart.yaml
            chart_version=$(yq e '.version' "$chart")
            # Find plugindefinition.yaml in the root directory
            plugin_yaml="$root_dir/plugindefinition.yaml"
            if [ -f "$plugin_yaml" ]; then
              # Update spec.helmChart.version in plugindefinition.yaml
              yq e -i ".spec.helmChart.version = \"$chart_version\"" "$plugin_yaml"
              echo "Updated $plugin_yaml to version $chart_version"

              # Bump spec.version based on update_level
              current_version=$(yq e '.spec.version' "$plugin_yaml")
              IFS='.' read -r major minor patch <<< "$current_version"
              case "$UPDATE_LEVEL" in
                major)
                  major=$((major + 1))
                  minor=0
                  patch=0
                  ;;
                minor)
                  minor=$((minor + 1))
                  patch=0
                  ;;
                patch|*)
                  patch=$((patch + 1))
                  ;;
              esac
              new_version="$major.$minor.$patch"
              yq e -i ".spec.version = \"$new_version\"" "$plugin_yaml"
              echo "Bumped $plugin_yaml spec.version to $new_version"

              git config user.name "github-actions[bot]"
              git config user.email "github-actions[bot]@users.noreply.github.com"
              git add "$plugin_yaml"
              git commit -m "chore: bump versions in $plugin_yaml"
              changes_made=true
            else
              echo "No plugindefinition.yaml found for $chart"
            fi
          done
          
          if [ "$changes_made" = true ]; then
            git push origin HEAD:${GITHUB_HEAD_REF}
            echo "changes_made=true" >> $GITHUB_OUTPUT
          fi
        env:
          files: ${{ steps.chartdiff.outputs.files }}
          UPDATE_LEVEL: ${{ steps.update_level.outputs.update_level }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Trigger other workflows
        if: steps.sync-versions.outputs.changes_made == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const repoUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}`;
            const triggeredWorkflows = [];
            
            // Function to get latest run ID for a workflow
            async function getLatestRunId(workflowId) {
              try {
                const { data: runs } = await github.rest.actions.listWorkflowRuns({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: workflowId,
                  per_page: 1,
                  page: 1
                });
                return runs.workflow_runs[0]?.id;
              } catch (error) {
                console.log(`Failed to get run ID for ${workflowId}:`, error.message);
                return null;
              }
            }
            
            // Trigger helm-lint-test workflow
            try {
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'helm-lint-test.yaml',
                ref: '${{ github.head_ref }}'
              });
              console.log('✅ Triggered helm-lint-test workflow');
              
              // Wait a moment for the run to be created
              await new Promise(resolve => setTimeout(resolve, 2000));
              
              const runId = await getLatestRunId('helm-lint-test.yaml');
              if (runId) {
                triggeredWorkflows.push({
                  name: 'Helm Lint & Test',
                  url: `${repoUrl}/actions/runs/${runId}`
                });
              } else {
                triggeredWorkflows.push({
                  name: 'Helm Lint & Test',
                  url: `${repoUrl}/actions/workflows/helm-lint-test.yaml`
                });
              }
            } catch (error) {
              console.log('❌ Failed to trigger helm-lint-test:', error.message);
            }
            
            // Trigger helm-docs workflow
            try {
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'helm-docs.yaml',
                ref: '${{ github.head_ref }}'
              });
              console.log('✅ Triggered helm-docs workflow');
              
              // Wait a moment for the run to be created
              await new Promise(resolve => setTimeout(resolve, 2000));
              
              const runId = await getLatestRunId('helm-docs.yaml');
              if (runId) {
                triggeredWorkflows.push({
                  name: 'Helm Docs',
                  url: `${repoUrl}/actions/runs/${runId}`
                });
              } else {
                triggeredWorkflows.push({
                  name: 'Helm Docs',
                  url: `${repoUrl}/actions/workflows/helm-docs.yaml`
                });
              }
            } catch (error) {
              console.log('❌ Failed to trigger helm-docs:', error.message);
            }
            
            // Create comment with specific run links if available
            const workflowLinks = triggeredWorkflows.map(wf => `- [${wf.name}](${wf.url})`).join('\n');
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `🤖 **Version Bump Complete** ✅

              Plugin versions have been synchronized and additional workflows have been triggered.

              📋 **View triggered workflows:**
              ${workflowLinks}

              *Note: Manually triggered workflows run independently and may not appear as PR status checks.*`
                          });